up:: [[üñ•Ô∏è C_C++]]
tags:: #state/seedling #on/cpp/23

# C++ 23 std

## \<expected\>
Similar to an optional. The class can contain or not a value and, contrary to an optional, **it specifies why it does not contains a value**.

It is used to make exceptions without using exceptions per se.

```cpp
enum class parse_error {
...
}

std::expected<double, parse_error>
parse_number(std::string str) {

}
```

[std::expected - cppreference.com](https://en.cppreference.com/w/cpp/utility/expected.html)

## \<optional\>
Puedes encadenar operaciones que devuelvan optionals con la funci√≥n `and_then`.

```cpp
std::optional<float> a();
std::optional<float> b();
std::optional<float> c();

int main() {
	// and_then checkea si el valor devuelto es utilizado
	auto returned = a().and_then(&b).and_then(&c);
}
```

## string_view
std::string copia una cadena. Si no queremos copiar una cadena, porque solo queremos acceder a ella, usamos `string_view`. No permite modificaciones de la cadena, solo acceder a ella como consulta.

```cpp
std::string_view s = "mi cadena";
```

## span
El span es similar al string_view, excepto que en vez de ser un visualizador de strings, es un visualizador de estructuras

```cpp
std::vector numeritor = {1, 2, 3, 4, 5};
std::span<int> sn{numeritor.data(), numeritor.data()+3};
int a = sn[2];
```

Tambi√©n existe el mdspan, que te crea un visor multidimensional para una estructura

```cpp
std::vector v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

auto ms2 = std::mdspan(v.data(), 2, 6);
auto ms3 = std::mdspan(v.data(), 2, 3, 2);

for(size_t i = 0; i != ms2.extent(0); i++) {
	for(size_t j = 0; j != ms2.extent(1); j++) {
		ms2[i,j] = i * j;
	}
}

for(size_t i = 0; i != ms3.extent(0); i++) {
	for(size_t j = 0; j != ms3.extent(1); j++) {
		for(size_t k = 0; k != ms3.extent(2); k++) {
		ms3[i,j,k] = i * j + k;
		}
	}
}
```

## map vs unordered_map vs flat_map

map = arbol binario ordenado
unordered_map = hashtable no ordenada, el m√°s r√°pido y eficiente
flat_map = usa la b√∫squeda binaria, es mejor cuando hay pocas inserciones y removals o cuando son mapas peque√±os (< 100 elementos)

## coroutines
```cpp
int three_values() {
	co_yield 1;
	co_yield 3;
	co_yield 6;
	return;
}

int main() {
	auto coroutine = three_values();
	std::cout << coroutine(); // prints 1
	std::cout << coroutine(); // prints 3
	std::cout << coroutine(); // prints 6
}
```

## constexpr y consteval
Esta keyword especifica que una variable es constante en tiempo de compilaci√≥n

```cpp
int bla = 12 * 3; // el compilador calcula la multiplicaci√≥n
int bla2 = bla + 3; // aqui no lo hace

constexpr int bla = 12 * 3; // el compilador calcula la multiplicaci√≥n
int bla2 = bla + 3;         // ahora s√≠ lo calcula
```

Similar a constexpr pero para funciones. Esa funci√≥n se realizar√° en compilaci√≥n y no existir√° en el c√≥digo fuente

```cpp
// [[nodiscard]] especifica al compilador que si no se devuelve nada, muestre un warning al compilar
[[nodiscard]] consteval suma(constexpr int a, constexpr int b) {
	if constexpr(a < b) {
		return a + b;
	}
	else {
		return a;
	}
}

[[nodiscard]] consteval division(constexpr int a, constexpr int b) {
	if constexpr(b == 0) {
		// se usa para definir que la funci√≥n nunca deber√≠a llegar aqu√≠. Mostrar√° un mensaje de error si es el caso. De este modo, se avisa al programador de que se ha alcanzado ese c√≥digo y no deber√≠a poderse.
		std::unreachable()
	}

	return a / b;
}
```

## References

---
Planted: 2023-03-21
Last tended: 2025-11-03